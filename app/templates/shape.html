<!DOCTYPE html>
<html lang="en">
  <head>
    <title>3D Curve</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>

    <script type="module">

      import * as THREE from "{{ url_for('static', filename='scripts/vendor/three.js-r116/build/three.module.js') }}";

      import Stats from "{{ url_for('static', filename='scripts/vendor/three.js-r116/examples/jsm/libs/stats.module.js') }}";   
      import { GUI } from "{{ url_for('static', filename='scripts/vendor/three.js-r116/examples/jsm/libs/dat.gui.module.js') }}";  

      import { OrbitControls } from "{{ url_for('static', filename='scripts/vendor/three.js-r116/examples/jsm/controls/OrbitControls.js') }}"; 

      var camera, scene, renderer, startTime, object, stats, T, B, N, B_curve, N_curve;

      var frame = 0;
      var maxFrame = 500;

      var startPoint = 0;
      var arr = get_points();
      var endPoint = arr.length;
      var pos = -1;

      var unit_tangeant = get_tangeant();
      var b_vector = get_b_vector();
      var n_vector = get_n_vector();

      var params = {
          showN: true,
          showB: true,
//          pause: 
      };

      init();
      animate();

      function init() {

          var gui = new GUI();
          gui.add( params, 'showN' );
          gui.add( params, 'showB' );

          
	  camera = new THREE.PerspectiveCamera( 36, window.innerWidth / window.innerHeight, 0.25, 1000 );
	  camera.position.set(-50, -20, 100);

	  scene = new THREE.Scene();

          // Line
          var material = new THREE.LineBasicMaterial( {
              color: 0x0000ff,
              linewidth: 3,
          } );

          var points = get_points();
          var geometry = new THREE.BufferGeometry().setFromPoints( points );
          object = new THREE.Line( geometry, material );
          scene.add( object );


          // test vector
          var origin = new THREE.Vector3({{center[0]}}, {{center[1]}}, {{center[2]}});

          var dir = new THREE.Vector3(0,0,0);
          //normalize the direction vector (convert to vector of length 1)
          dir.normalize()

          var length = 1;
          var hex = 0xffffff;
          
          T = new THREE.ArrowHelper( dir, origin, length, hex );
          scene.add( T );

          B = new THREE.ArrowHelper( dir, origin, length, hex );
          scene.add( B );

          N = new THREE.ArrowHelper( dir, origin, length, hex );
          scene.add( N );
          

	  // Stats
	  stats = new Stats();
	  document.body.appendChild( stats.dom );

	  // Renderer
	  renderer = new THREE.WebGLRenderer();
	  renderer.shadowMap.enabled = true;
	  renderer.setPixelRatio( window.devicePixelRatio );
	  renderer.setSize( window.innerWidth, window.innerHeight );
	  window.addEventListener( 'resize', onWindowResize, false );
	  document.body.appendChild( renderer.domElement );

	  // Controls
	  var controls = new OrbitControls( camera, renderer.domElement );
	  controls.target.set({{center[0]}}, {{center[1]}}, {{center[2]}}); // barycenter of the curve
 	  controls.update();


	  // Start
	  startTime = Date.now();

      }

      function onWindowResize() {

	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize( window.innerWidth, window.innerHeight );
      }


     
      function animate() {
	  var currentTime = Date.now();
	  var time = ( currentTime - startTime ) / 1000;

          setTimeout( function() {
              requestAnimationFrame( animate );
          }, 1000 / 30 );


	  //object.position.y = 0.8;
//	  object.rotation.x = time * 0.5;
//	  object.rotation.y = time * 0.2;
          //	  object.scale.setScalar( Math.cos( time ) * 0.125 + 0.875 );


          if (pos == -1){
              var material = new THREE.LineBasicMaterial( {
                  color: 0x00ff00,
                  linewidth: 1,
              } );
              var points = b_vector.slice(0, 2)
              var geometry = new THREE.BufferGeometry().setFromPoints( points );
              B_curve = new THREE.Line( geometry, material );
              scene.add( B_curve );


              var material = new THREE.LineBasicMaterial( {
                  color: 0xff0000,
                  linewidth: 1,
              } );
              var points = n_vector.slice(0, 2)
              var geometry = new THREE.BufferGeometry().setFromPoints( points );
              N_curve = new THREE.Line( geometry, material );
              scene.add( N_curve );

              
              pos = 0;
          }



          
          var per = frame / maxFrame,
              rad = Math.PI * 2 * per,
              x = Math.cos(rad),
              y = Math.sin(rad);


          var tmp = arr[pos];

          T.position.copy(tmp);
          B.position.copy(tmp);
          N.position.copy(tmp);
          pos++;
          if(pos >= endPoint -1){ pos = 0;}

          var dir = unit_tangeant[pos]
          T.setDirection(dir.normalize());
          
          dir = b_vector[pos]
          B.setDirection(dir.normalize());

          dir = n_vector[pos]
          N.setDirection(dir.normalize());



          var points = get_b_vector().slice(0, pos+1)
          for(var i=0; i < points.length; ++i){
              points[i].normalize()
                  .add(arr[i])
          }

          var geometry
          if(!params.showB){
              geometry = new THREE.BufferGeometry().setFromPoints( [] );
          } else {
              geometry = new THREE.BufferGeometry().setFromPoints( points );
          }
          B_curve.geometry.dispose();
          B_curve.geometry = geometry;

          
          var points = get_n_vector().slice(0, pos+1)
          for(var i=0; i < points.length; ++i){
              points[i].normalize()
                  .add(arr[i])
          }

          if(!params.showN){
              geometry = new THREE.BufferGeometry().setFromPoints( [] );
          } else {
              geometry = new THREE.BufferGeometry().setFromPoints( points );
          }
          N_curve.geometry.dispose();
          N_curve.geometry = geometry;

          
          frame += 1;
          frame %= maxFrame;

	  stats.begin();
	  renderer.render( scene, camera );
	  stats.end();
      }


      function get_points() {
          var points = [];
          
          {% for point in points %}
          points.push( new THREE.Vector3({{point[0]}}, {{point[1]}}, {{point[2]}} ) );
          {% endfor %}
          
          return points;

      }

      function get_tangeant() {
          var points = [];
          
          {% for point in unit_tangeant %}
          points.push( new THREE.Vector3({{point[0]}}, {{point[1]}}, {{point[2]}} ) );
          {% endfor %}
          
          return points;

      }

      function get_b_vector() {
          var points = [];
          
          {% for point in b_vector %}
          points.push( new THREE.Vector3({{point[0]}}, {{point[1]}}, {{point[2]}} ) );
          {% endfor %}
          
          return points;

      }

      function get_n_vector() {
          var points = [];
          
          {% for point in n_vector %}
          points.push( new THREE.Vector3({{point[0]}}, {{point[1]}}, {{point[2]}} ) );
          {% endfor %}
          
          return points;

      }

      
    </script>

  </body>
</html>
